---
layout:     post
title:      "《深入理解JVM》读书笔记（三）"
subtitle:   "学习总结"
date:       2017-07-22 12:00:00
author:     "溜大虾"
header-img: "img/jvm-3.jpg"
header-mask: 0.3
catalog:    true
tags:
    - Java
    

---

## 第三章 垃圾收集器与内存分配策略

## 对象已死吗？

## 1.引用计数法

1.主流的Java虚拟机里面没有选用引用计数算法来管理内存，其中最主要的原因是他很难解决对象之间互相引用的问题。  

## 2.可达性分析算法

1.主流的商用程序语言的主流实现中都是用可达性分析来判断对象是否存活的2.从一个起始对象GC Roots开始向下搜索，搜索所走过的路径称为引用链，档一个对象到GC Roots没有任何引用链时，即从GC Roots到这个对象不可达，则证明此对象是不可用的3.在Java语言中，可作为GC Roots的对象包括一下四种：

- 虚拟机栈（栈帧中的本地变量表）中引用的对象  
- 方法区中类静态属性引用的对象  
- 方法区中常亮引用的对象  
- 本地方法栈中JNI引用的对象  

## 3.再谈引用

1.Java的引用可以分为强引用、软引用、弱引用、虚引用：  

- 强引用：是指在程序代码中直接存在的引用，譬如引用new操作符创建的对象。只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象  
- 软引用：还有用但是并非必需的引用，早系统将要发生内存溢出异常之前会把这些对象列进回收范围中进行二次回收，若还是没有足够的内存，才会抛出内存溢出异常  
- 弱引用：非必需的对象，只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论内存是否够用都将回收这些对象  
- 虚引用：一个对象是否有虚引用的存在完全不会对他的生存时间构成影响，也无法通过虚引用来取得一个对象实例  

## 4.生存还是死亡

1.要真正宣告一个对象死亡，需要两个标记过程：

- 若对象在进行可达性分析后发现没有与GC Roots相连接的引用链，会被第一次标记并筛选。筛选的条件是此对象是否有必要执行finalize()方法  
- finalize()方法是对象逃脱死亡的最后一次机会，稍后GC会对对象进行第二次标记  

2.当对象没有覆盖finalize()方法或者finalize()方法已经由虚拟机调用过，都视为finalize()没有必要执行  

## 5.回收方法区

1.永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类2.类需要同时满足一下三个条件才能算是“无用的类”：

- 该类所有的实例都已经被回收，即Java堆中不再有该类的实例  
- 加载该类的ClassLoader已经被回收  
- 该类对应的java.lang.Class对象没有在任何地方被调用，无法在任何地方通过反射访问该类的方法  

## 垃圾收集算法

## 1.标记-清楚算法

1.算法分为两个阶段：标记和清除  

- 标记：标记所有需要回收的对象  
- 清除：统一回收所有被标记的对象  

2.优点:简单，是后面其他算法的基础3.缺点：标记和清除的效率很低；标记清除之后会产生大量不连续的内存碎片，空间碎片太多会导致以后遇到大对象的时候无法找到足够的内存  

## 2.复制算法

1.思路：将可用内存按容量分为两个块，每次只用其中之一。当这一块内存用完之后，将还存活的对象复制到另一边去，然后清除所有已经使用过的部分2.优点：实现简单，运行高效3.缺点：代价是将内存缩小了一部分，而且可能会需要额外的担保空间  

## 3.标记-整理算法

1.思路：标记过程和标记-清除一样，但是后续步骤不是直接对可回收对象进行清理，而是将所有活着的对象向一端移动，然后直接清理掉端边界以外的内存  

## 4.分代收集算法

1.当前商用虚拟机都采用了这种算法，根据对象的存活周期将内存划分为几块，一般是把Java堆分为新生代和老生代，根据各个年代采用适当的收集算法2.新生代一般采用复制算法，老生代一搬采用 标记-清理 或者标记-整理 进行回收  

## HotSpot的算法实现

## 1.枚举根节点

1.目前主流的Java虚拟机使用的都是准确式GC，当执行系统停顿下来后并不需要一个不漏的检查完所有执行上下文和全局的引用变量，虚拟机应当有办法直接得知哪些地方存着对象的引用2.HotSpot使用一组称为OopMap的数据结构来记录哪些地方存着对象的引用3.在类加载过程中，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中会在特定的位置记录下栈和寄存器中哪些位置是引用  

## 2.安全点

1.HotSpot没有为每条指令都生成OopMap，只是在特定位置记录了这些信息，这些位置称为安全点2.程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停3.给多线程记录安全点时有两种方案：抢先式中断 和 主动式中断4.主动式中断的思想是当GC需要中断线程时不直接对线程进行操作，仅仅简单的设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起  

## 3.安全区域

1.为了处理“不执行”的程序的安全点问题，提出了安全区域来解决问题2.安全区域是指在一段代码片段之中，引用关系不会发生变化，在这个区域内的任何地方进行GC都是安全的3.虚拟机如歌具体的进行内存回收是由虚拟机所采用的GC收集器决定的，而通常虚拟机中往往不止有一种GC收集器  

## 垃圾收集器

- 如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现  
- 不同的收集器应用的区域不同，到现在为止没有最好的收集器，也没有万能的收集器  

## 1.Serial收集器

1.Serail收集器是“单线程”的，他在进行垃圾收集时必须暂停其他的所有线程，直到收集结束2.随着收集器的发展，用户线程的停顿时间越来越段，但任然无法消除3.Serial收集器是虚拟机运行在Client模式下默认的新生代收集器4.对于单个CPU坏境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集，可以获得很高的单线程收集效率  

## 2.ParNew收集器

1.ParNew收集器是Serial收集器的多线程版本2.ParNew收集器是运行在Server模式下虚拟机中首选的新生代收集器3.在垃圾收集器中“并发”与“并行”的概念：

- 并行：多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态  
- 并发：用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行在另一个CPU上

## 3.Parallel Scavenge收集器

1.Parallel Scavenge收集器是一个新生代收集器，采用复制算法2.Parallel Scavenge收集器的特点是他的关注点与其他收集器不同。其他收集器的目标是尽可能的缩短用户线程的停顿时间，而Parallel Scavenge收集器的目标是达到一个可控的吞吐量3.高吞吐量可以高效的利用CPU时间，尽快得完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务4.GC停顿时间的缩短是以牺牲吞吐量和新生代空间来换取的5.Parallel Scavenge收集器也经常被称为“吞吐量优先”收集器  

## 4.Serail Old收集器

1.Serial Old收集器是Serail收集器的老年代版本，是一个单线程收集器，使用标记-整理算法2.Serail Old收集器主要用于Clinet模式下3.Serail Old收集器另一种用途是作为CMS收集器的后备预案  

## 5.Parallel Old收集器

Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程和标记-整理算法2，在注重吞吐量和CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器  

## 6.CMS收集器

1.CMS收集器是一种以获取最短的回收停顿时间为目标的收集器2.CMS收集器基于标记-清楚算法实现，分为四个步骤：初始标记、并发标记、重新标记、并发清除3.步骤详解：

- 初始标记：标记一下GC Roots能直接关联到的对象，速度很快  
- 并发标记：进行GC Roots Tracing  
- 重新标记：是为了修正那些在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，在这一阶段的停顿时间会比初始标记阶段稍长一点  

4.从总体上说，CMS收集器的内存回收过程是与用户线程一起并发执行的5.CMS收集器的缺点：  

- CMS收集器对CPU资源非常敏感  
- CMS收集器无法处理浮动垃圾，可能出现“Concurrent Mode Failure”失败而导致另一次Full FC的产生  
- 由于CMS收集器采用了标记-清除算法，所以在回收结束时会有大量空间碎片产生，碎片过多时，在给大对象分配内存时会有很大麻烦  

## 7.G1收集器

1.G1收集器是一款面向服务端应用的垃圾收集器2.G1收集器具备以下特点：  

- 并行与并发  
- 分代收集
- 空间整合：从整体上来看是基于“标记-整理”算法实现的，在局部上是基于复制算法实现的  
- 可预测的停顿   

3.G1收集器将整个Java堆划分为多个大小相等的独立区域，虽然还保留有新生代和老生代的概念，但新生代和老生代不再是物理隔的了，他们是一部分Region的集合4.G1收集器可以有计划地避免在整个Java堆中进行全区域的垃圾收集：跟踪各个Region里面的垃圾堆积的价值大小，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region5.在G1收集器中，使用Remembered Set来避免全堆扫描   

## 内存分配与回收的策略

对象的内存分配，往大方向讲，就是在堆上分配，主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配，少数情况也可能会直接分配在老年代中，具体的分配规则取决于虚拟机自己的设置  

## 1.对象优先在Eden区分配

1.大多数情况下，对象优先在新生代的Eden区分配2.当Eden区没有足够的空间时，虚拟机将发起一次Minor GC3.Minor GC与Full GC：

- Minor GC：新生代GC，非常频繁，回收速度快  
- Fulll GC：老年代GC，又称为Major GC，经常会伴随一次Minor GC，速度比较慢  

## 2.大对象直接进入老年代

1.大对象是指需要大量连续的内存空间的Java对象2.虚拟机提供了一个参数：PretenureSizeThreshold，大于这个参数的对象将直接在老年代分配  

## 3.长期存活的对象将进入老年代

1.虚拟机给每个对象定义了一个对象年龄计数器（Age），对象每经过一次Minor GC后仍然存活，且能被Survivor容纳的话，年龄就 +1 ，当年龄增加到一定程度（默认为15），就会被晋升到老年代中，这个阈值可以通过参数 MaxTenuringThreshold 来设置  

## 4.动态对象年龄的判定

1.为了更好的适应不同程序的内存状况，对象年龄不是必须到达阈值才会进入老年代2.当Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，或年龄大于等于该年龄的对象就可以直接进入老年代  

## 5.空间分配担保

1.在发生Minor GC之前，虚拟机会首先检查老年代可用最大内存空间是否大于新生代对象总空间—若大于，则会进行一次安全的Minor GC2.若上述条件不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败，若不允许，则进行一次FULL GC3.若允许担保失败，则虚拟机会检查老年代最大可用的连续空间是否大于历次晋升到老年代的对象的平均大小，若大于，则进行一次冒险的Minor GC，否则进行一次FULL GC4.若担保失败，还是会进行一次FULL GC。之所以要冒险的原因是为了避免频繁的FULL GC  